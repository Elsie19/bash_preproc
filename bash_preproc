#!/usr/bin/env bash

INPUT="${1}"

shebang_regex='#!\/.+$'

# Global
lines_with_directive_global=($(grep -rn -E '#include <[a-zA-Z]+.sh|bash>$' "${INPUT}" | awk 'BEGIN { FS=":" } { print $1 }'))
# Local to script
lines_with_directive_local=($(grep -rn -E '#include \".+\.(sh|bash)\"$' "${INPUT}" | awk 'BEGIN { FS=":" } { print $1 }'))

if [[ -n ${lines_with_directive_global[*]} ]]; then
    for directive in "${lines_with_directive_global[@]}"; do
        contents="$(awk "{if(NR=="$directive") print \$0}" "$INPUT")"
        # Removes `#include <` and `>`
        contents="${contents:10:-1}"
        if [[ ! -f "/usr/include/bash/$contents" ]]; then
            echo "[$directive] :: Could not find bash file at \`/usr/include/bash/$contents\`"
            # Gotta fail out fast
            exit 1
        else
            # Directive name: `potato.sh`
            final_directives+=("$contents")
            # Line number
            final_directives_lines+=("$directive")
        fi
    done
    if [[ -n ${final_directives[*]} ]]; then
        # Reverse so we can put in files without messing up line numbers
        final_directives=($(
            printf '%s\n' "${final_directives[@]}" | tac | tr '\n' ' '
            echo
        ))
        final_directives_lines=($(
            printf '%s\n' "${final_directives_lines[@]}" | tac | tr '\n' ' '
            echo
        ))
        for directive in "${!final_directives[@]}"; do
            # Set line after in order to make sure the directive stays on the same line for removal
            directive_line="$((${final_directives_lines[directive]} + 1))"
            # Insert directive
            sed -i -e "$directive_line { r /usr/include/bash/${final_directives[directive]}" -e "N; }" "${INPUT}"
            # Remove directive line
            sed -i "${final_directives_lines[directive]}d" "${INPUT}"
            # Remove directive shebang if included
            if [[ "$(sed "${final_directives_lines[directive]}q;d" "${INPUT}")" =~ $shebang_regex ]]; then
                sed -i "${final_directives_lines[directive]}d" "${INPUT}"
                sed -i "${final_directives_lines[directive]}d" "${INPUT}"
            fi
            echo -e ":: Inserted \`${final_directives[directive]}\`"
        done
    fi
fi

unset final_directives
unset final_directives_lines

if [[ -n ${lines_with_directive_local[*]} ]]; then
    for directive in "${lines_with_directive_local[@]}"; do
        contents="$(awk "{if(NR=="$directive") print \$0}" "$INPUT")"
        # Removes `#include <` and `>`
        contents="${contents:10:-1}"
        if [[ ! -f "$PWD/$contents" ]]; then
            echo "[$directive] :: Could not find bash file at \`$PWD/$contents\`"
            # Gotta fail out fast
            exit 1
        else
            # Directive name: `potato.sh`
            final_directives+=("$contents")
            # Line number
            final_directives_lines+=("$directive")
        fi
    done
    if [[ -n ${final_directives[*]} ]]; then
        # Reverse so we can put in files without messing up line numbers
        final_directives=($(
            printf '%s\n' "${final_directives[@]}" | tac | tr '\n' ' '
            echo
        ))
        final_directives_lines=($(
            printf '%s\n' "${final_directives_lines[@]}" | tac | tr '\n' ' '
            echo
        ))
        for directive in "${!final_directives[@]}"; do
            # Set line after in order to make sure the directive stays on the same line for removal
            directive_line="$((${final_directives_lines[directive]} + 1))"
            # Insert directive
            sed -i -e "$directive_line { r $PWD/${final_directives[directive]}" -e "N; }" "${INPUT}"
            # Remove directive line
            sed -i "${final_directives_lines[directive]}d" "${INPUT}"
            # Remove directive shebang if included
            if [[ "$(sed "${final_directives_lines[directive]}q;d" "${INPUT}")" =~ $shebang_regex ]]; then
                sed -i "${final_directives_lines[directive]}d" "${INPUT}"
                sed -i "${final_directives_lines[directive]}d" "${INPUT}"
            fi
            echo -e ":: Inserted \`${final_directives[directive]}\`"
        done
    fi
fi

if [[ -z ${lines_with_directive_local[*]} ]] || [[ -z ${lines_with_directive_global[*]} ]]; then
    echo ":: No preprocessor directives found!"
    exit 1
fi
